<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D3 Grid Visualization with Clusters</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* Container holding SVG and Sidebar */
        #container {
            display: flex;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        /* SVG Styling */
        svg {
            flex-grow: 1;
            background-color: #dddddd; /* Lighter grey background */
            cursor: move;
        }

        /* Sidebar Styling */
        #sidebar {
            width: 300px; /* Fixed width for the sidebar */
            background-color: #f0f0f0; /* Slightly different grey for contrast */
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
            font-family: sans-serif;
            font-size: 14px;
            border-left: 1px solid #cccccc;
        }

        /* Optional: Style for the sidebar content */
        #sidebar h2 {
            margin-top: 0;
        }

        /* Transition for smooth opacity changes */
        rect {
            transition: fill-opacity 0.3s;
        }
    </style>
</head>
<body>
    <!-- Container Div -->
    <div id="container">
        <!-- SVG Container -->
        <svg></svg>

        <!-- Sidebar Div -->
        <div id="sidebar">
            <h2>Grid Cell Information</h2>
            <p>Hover over a cell to see details here.</p>
        </div>
    </div>

    <script>
        // Main function to initialize the visualization and handle data download
        function initVisualization() {
            const svg = d3.select("svg");
            const sidebar = d3.select("#sidebar");

            // Define the color scale for clusters
            const colorScale = d3.scaleOrdinal(d3.schemeCategory10);

            // Define grid dimensions
            const numCols = 200;
            const numRows = 200;

            // Load data and render the grid
            d3.csv("https://raw.githubusercontent.com/luobogao/Helen-Analysis/refs/heads/master/ratios_xy.csv")
                .then(data => renderGrid(data))
                .catch(error => console.error('Error loading the data:', error));

            // Function to render the grid
            function renderGrid(data) {
                // Parse the data
                data.forEach(d => {
                    d.X = +d.X;
                    d.Y = +d.Y;
                    d.cluster = +d.cluster;
                });

                const containerWidth = svg.node().clientWidth;
                const containerHeight = svg.node().clientHeight;

                const originalXExtent = d3.extent(data, d => d.X);
                const originalYExtent = d3.extent(data, d => d.Y);

                const xRange = originalXExtent[1] - originalXExtent[0];
                const yRange = originalYExtent[1] - originalYExtent[0];
                const buffer = 0.1;

                const bufferedXExtent = [
                    originalXExtent[0] - buffer * xRange,
                    originalXExtent[1] + buffer * xRange
                ];
                const bufferedYExtent = [
                    originalYExtent[0] - buffer * yRange,
                    originalYExtent[1] + buffer * yRange
                ];

                const extendedXRange = bufferedXExtent[1] - bufferedXExtent[0];
                const extendedYRange = bufferedYExtent[1] - bufferedYExtent[0];

                const scaleX = containerWidth / extendedXRange;
                const scaleY = containerHeight / extendedYRange;
                const scale = Math.min(scaleX, scaleY);

                const scaledWidth = extendedXRange * scale;
                const scaledHeight = extendedYRange * scale;
                const paddingX = (containerWidth - scaledWidth) / 2;
                const paddingY = (containerHeight - scaledHeight) / 2;

                const xScale = d3.scaleLinear()
                    .domain(bufferedXExtent)
                    .range([paddingX, paddingX + scaledWidth]);

                const yScale = d3.scaleLinear()
                    .domain(bufferedYExtent)
                    .range([paddingY + scaledHeight, paddingY]);

                const cellWidth = extendedXRange / numCols;
                const cellHeight = extendedYRange / numRows;
                const cellSize = Math.min(
                    xScale(bufferedXExtent[0] + cellWidth) - xScale(bufferedXExtent[0]),
                    yScale(bufferedYExtent[0]) - yScale(bufferedYExtent[0] + cellHeight)
                );

                const grid = [];
                for (let j = 0; j < numRows; j++) {
                    for (let i = 0; i < numCols; i++) {
                        grid.push({
                            x0: bufferedXExtent[0] + i * cellWidth,
                            x1: bufferedXExtent[0] + (i + 1) * cellWidth,
                            y0: bufferedYExtent[0] + j * cellHeight,
                            y1: bufferedYExtent[0] + (j + 1) * cellHeight,
                            clusters: [],
                            majorityCluster: null
                        });
                    }
                }

                data.forEach(d => {
                    const i = Math.floor((d.X - bufferedXExtent[0]) / cellWidth);
                    const j = Math.floor((d.Y - bufferedYExtent[0]) / cellHeight);
                    const clampedI = Math.min(Math.max(i, 0), numCols - 1);
                    const clampedJ = Math.min(Math.max(j, 0), numRows - 1);
                    grid[clampedJ * numCols + clampedI].clusters.push(d.cluster);
                });

                grid.forEach(cell => {
                    if (cell.clusters.length > 0) {
                        const clusterCounts = d3.rollup(cell.clusters, v => v.length, d => d);
                        cell.majorityCluster = Array.from(clusterCounts.entries()).reduce((a, b) => a[1] > b[1] ? a : b)[0];
                    }
                });

                const flattenedGrid = grid.filter(d => d.majorityCluster !== null);

                const counts = flattenedGrid.map(d => d.clusters.length);
                const minCount = 1
                const maxCount = 10

                const opacityScale = d3.scaleLinear()
                    .domain([minCount, maxCount])
                    .range([0.2, 1]);

                const zoomGroup = svg.append("g");

                const rectangles = zoomGroup.selectAll("rect")
                    .data(flattenedGrid)
                    .enter().append("rect")
                    .attr("x", d => xScale(d.x0))
                    .attr("y", d => yScale(d.y1))
                    .attr("width", cellSize + 1)
                    .attr("height", cellSize + 1)
                    .attr("fill", d => colorScale(d.majorityCluster))
                    .attr("fill-opacity", d => opacityScale(d.clusters.length))
                    .on("mouseover", (event, d) => {
                        rectangles
                            .transition()
                            .duration(200)
                            .attr("fill-opacity", cellData => 
                                cellData === d ? opacityScale(cellData.clusters.length) : 0.05
                            );

                        sidebar.html(`
                            <h2>Grid Cell Information</h2>
                            <p><strong>Majority Cluster:</strong> ${d.majorityCluster}</p>
                            <p><strong>Number of Points:</strong> ${d.clusters.length}</p>
                            <p><strong>Cell Coordinates:</strong> (${d.x0.toFixed(2)}, ${d.y0.toFixed(2)}) to (${d.x1.toFixed(2)}, ${d.y1.toFixed(2)})</p>
                        `);
                    })
                    .on("mouseout", () => {
                        rectangles
                            .transition()
                            .duration(200)
                            .attr("fill-opacity", d => opacityScale(d.clusters.length));

                        sidebar.html(`
                            <h2>Grid Cell Information</h2>
                            <p>Hover over a cell to see details here.</p>
                        `);
                    });

                const zoomBehavior = d3.zoom()
                    .scaleExtent([0.5, 20])
                    .translateExtent([[0, 0], [containerWidth, containerHeight]])
                    .on("zoom", event => {
                        zoomGroup.attr("transform", event.transform);
                    });

                svg.call(zoomBehavior)
                    .call(zoomBehavior.transform, d3.zoomIdentity);
            }

            // Handle window resize
            function handleResize() {
                svg.selectAll("g").remove();
                initVisualization();
            }

            let resizeTimeout;
            window.addEventListener("resize", () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(handleResize, 200);
            });
        }

        // Initialize the visualization on page load
        initVisualization();
    </script>
</body>
</html>
